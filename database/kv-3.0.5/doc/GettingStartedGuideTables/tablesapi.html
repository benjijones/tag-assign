<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 4. Introducing Oracle NoSQL Database Tables and Indexes</title>
    <link rel="stylesheet" href="gettingStarted.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="start" href="index.html" title="Getting Started with Oracle NoSQL Database Tables" />
    <link rel="up" href="index.html" title="Getting Started with Oracle NoSQL Database Tables" />
    <link rel="prev" href="authentication.html" title="Using the Authentication APIs" />
    <link rel="next" href="createindex.html" title="Creating Indexes" />
  </head>
  <body>
    <div xmlns="" class="navheader">
      <div class="libver">
        <p>Library Version DRAFT</p>
      </div>
      <table width="100%" summary="Navigation header">
        <tr>
          <th colspan="3" align="center">Chapter 4. Introducing Oracle NoSQL Database Tables and Indexes</th>
        </tr>
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="authentication.html">Prev</a> </td>
          <th width="60%" align="center"> </th>
          <td width="20%" align="right"> <a accesskey="n" href="createindex.html">Next</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="chapter" lang="en" xml:lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="tablesapi"></a>Chapter 4. Introducing Oracle NoSQL Database Tables and Indexes</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <p>
          <b>Table of Contents</b>
        </p>
        <dl>
          <dt>
            <span class="sect1">
              <a href="tablesapi.html#tabledefine">Defining Tables</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="sect2">
                  <a href="tablesapi.html#defchildtable">Defining Child Tables</a>
                </span>
              </dt>
              <dt>
                <span class="sect2">
                  <a href="tablesapi.html#tablesdatatypes">Supported Table Data Types</a>
                </span>
              </dt>
              <dt>
                <span class="sect2">
                  <a href="tablesapi.html#recordfields">Record Fields</a>
                </span>
              </dt>
              <dt>
                <span class="sect2">
                  <a href="tablesapi.html#tablefromavro">Defining Tables using Existing Avro Schema</a>
                </span>
              </dt>
              <dt>
                <span class="sect2">
                  <a href="tablesapi.html#tableevolve">Table Evolution</a>
                </span>
              </dt>
              <dt>
                <span class="sect2">
                  <a href="tablesapi.html#tablecommands">Table Manipulation Commands</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="sect1">
              <a href="createindex.html">Creating Indexes</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="sect2">
                  <a href="createindex.html#indexcommands">Index Manipulation Commands</a>
                </span>
              </dt>
            </dl>
          </dd>
        </dl>
      </div>
      <p>
      The Oracle NoSQL Database tables API is the recommended method of coding an Oracle NoSQL Database
      client application. It allows you to manipulate data using a tables
      metaphor, in which data is organized in multiple columns of data.
      An unlimited number of subtables are supported by this API. You can
      also create indexes to improve query speeds against your tables.
  </p>
      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
        <h3 class="title">Note</h3>
        <p>
          You should avoid any possibility of colliding keys if your store is
          accessed by a mix of clients that use both the tables and the
          key/value APIs. 
      </p>
      </div>
      <p>
      Table creation, deletion and evolution is performed using the command
      line interface (CLI). You use the CLI to define tables, including the
      data types supported by each column in the table. You also use the
      CLI to define indexes. Once you have created your table(s) using the
      CLI, you then use the tables API to read and write the data stored in
      those tables.
  </p>
      <div class="sect1" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="tabledefine"></a>Defining Tables</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <dl>
            <dt>
              <span class="sect2">
                <a href="tablesapi.html#defchildtable">Defining Child Tables</a>
              </span>
            </dt>
            <dt>
              <span class="sect2">
                <a href="tablesapi.html#tablesdatatypes">Supported Table Data Types</a>
              </span>
            </dt>
            <dt>
              <span class="sect2">
                <a href="tablesapi.html#recordfields">Record Fields</a>
              </span>
            </dt>
            <dt>
              <span class="sect2">
                <a href="tablesapi.html#tablefromavro">Defining Tables using Existing Avro Schema</a>
              </span>
            </dt>
            <dt>
              <span class="sect2">
                <a href="tablesapi.html#tableevolve">Table Evolution</a>
              </span>
            </dt>
            <dt>
              <span class="sect2">
                <a href="tablesapi.html#tablecommands">Table Manipulation Commands</a>
              </span>
            </dt>
          </dl>
        </div>
        <p>
          Before an Oracle NoSQL Database client can read or write to a table in the store,
          the table must be created using the command line interface (CLI).
          While it is possible to define tables interactively using the
          CLI, doing so represents challenges when developing table
          definitions for use in an enterprise environment. In order to
          avoid typos as code moves from the development environment, to
          test, to production, it is best to perform table definitions
          using a script. 
      </p>
        <p>
          A CLI script is simply a series of CLI commands contained in a
          single text file, one command to a line. To run the script, you
          start the CLI and then use the <code class="literal">load</code> command.
      </p>
        <p>
          For example, suppose you wanted to use a table named
          <code class="literal">myTable</code> with four columns per row:
          <code class="literal">item</code>, <code class="literal">count1</code>,
          <code class="literal">count2</code>, and <code class="literal">percentage</code>. 
          To create this table, you can log into the CLI and use the
          <code class="literal">table create</code>, <code class="literal">add-field</code>,
          <code class="literal">primary-key</code>, and <code class="literal">plan add-table</code>
          commands interactively. Or you can just collect all these
          commands into a plain text file like this:
      </p>
        <pre class="programlisting">## Enter into table creation mode
## This enters into a submode for the CLI, which offers
## commands specifically used to define tables.
table create -name myTable
## Now add the fields
add-field -type STRING -name item
add-field -type STRING -name description
add-field -type INTEGER -name count
add-field -type DOUBLE -name percentage
## A primary key must be defined for every table
## Here, we will define field 'item' as the primary key.
primary-key -field item
## Exit table creation mode, returning to the 
## main CLI commands.
exit
## Add the table to the store. Use the -wait flag to
## force the script to wait for the plan to complete
## before doing anything else.
plan add-table -name myTable -wait </pre>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
          <h3 class="title">Note</h3>
          <p>
            Primary keys are a concept that have not yet been introduced in
            this manual. See
            <a class="xref" href="primaryshardkeys.html" title="Chapter 5. Primary and Shard Key Design">Primary and Shard Key Design</a>
            for a complete explanation on what they are and how you should
            use them.
        </p>
        </div>
        <p>
        To run the script, start the CLI and then use the
        <code class="literal">load</code> command. Suppose you placed the above
        script into a file named <code class="literal">createTable.txt</code>:
    </p>
        <pre class="programlisting">&gt; java -Xmx256m -Xms256m \
-jar KVHOME/lib/kvstore.jar runadmin -host &lt;hostName&gt; \
-port &lt;port&gt; -store &lt;storeName&gt;
kv-&gt; load -file createTable.txt
Table myTable built
Executed plan 8, waiting for completion...
Plan 8 ended successfully

kv-&gt; </pre>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
          <h3 class="title">Note</h3>
          <p>
              The above example assumes you are connecting to a nonsecure
              store. If you are using a secure store, then you will have to
              authenticate when you start the CLI. You do this using the 
              <code class="literal">-admin-security</code> command line option.
          </p>
        </div>
        <p>
          By performing all your table and index manipulation in this way,
          you can ensure a consistent store environment all the way through
          your development/test/product deployment cycle.
      </p>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="defchildtable"></a>Defining Child Tables</h3>
              </div>
            </div>
          </div>
          <p>
              Oracle NoSQL Database tables can be organized in a parent/child hierarchy.
              There is no limit to how many child tables you can create,
              nor is there a limit to how deep the child table nesting can
              go.
          </p>
          <p>
              Child tables are not retrieved when you retrieve a parent
              table, nor is the parent retrieved when you retrieve a child
              table.
          </p>
          <p>
              To create a child table, you name the table using the format:
              <span class="emphasis"><em>&lt;parentTableName&gt;.&lt;childTableName&gt;</em></span>. 
              For example, we previously showed how to create a trivial
              table called <code class="literal">myTable</code>: 
          </p>
          <pre class="programlisting">## Enter into table creation mode
table create -name myTable
## Now add the fields
add-field -type STRING -name itemCategory
add-field -type STRING -name description
## A primary key must be defined for every table
## Here, we will define field 'itemCategory' as the primary key.
primary-key -field itemCategory
## Exit table creation mode
exit
## Add the table to the store. Use the -wait flag to
## force the script to wait for the plan to complete
## before doing anything else.
plan add-table -name myTable -wait </pre>
          <p>
              We can create a child table called
              <code class="literal">myChildTable</code> in the following way:
            </p>
          <pre class="programlisting">## Enter into table creation mode
## This 'table create' will fail if 'plan add-table -name myTable'
## is not run first.
table create -name myTable.myChildTable
## Now add the fields
add-field -type STRING -name itemSKU
add-field -type STRING -name itemDescription
add-field -type FLOAT -name price
add-field -type INTEGER -name inventoryCount
## Define the primary key
primary-key -field itemSKU
## Exit table creation mode
exit
## Add the table to the store.
plan add-table -name myTable.myChildTable -wait </pre>
          <p>
                Note that when you do this, the child table inherits the
                parent table's primary key. In this trivial case, the child
                table's primary key is actually the two fields:
                <code class="literal">itemCategory</code> and <code class="literal">itemSKU</code>.
                This has several ramifications, one of which is that the
                parent's primary key fields are retrieved when you retrieve
                the child table. See 
                <a class="xref" href="singleget.html#getChild" title="Retrieve a Child Table">Retrieve a Child Table</a>
                for more information.
            </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="tablesdatatypes"></a>Supported Table Data Types</h3>
              </div>
            </div>
          </div>
          <p>
              You specify schema for each column in an Oracle NoSQL Database table. This schema can be a
              simple data type, or complex data type.
          </p>
          <p>
              Supported simple data types are:
          </p>
          <div class="itemizedlist">
            <ul type="disc">
              <li>
                <p>
                      Boolean
                  </p>
              </li>
              <li>
                <p>
                      Double
                  </p>
              </li>
              <li>
                <p>
                      Float
                  </p>
              </li>
              <li>
                <p>
                      Integer
                  </p>
              </li>
              <li>
                <p>
                      Long
                  </p>
              </li>
              <li>
                <p>
                      Java byte array
                  </p>
              </li>
              <li>
                <p>
                      Java String
                  </p>
              </li>
            </ul>
          </div>
          <p>
              Supported complex data types are non-atomic in nature, and
              are manipulated as class objects. In some cases, this allows
              Oracle NoSQL Database to ensure some data restrictions are met, such as minimum
              and maximum data values.  The complex data types are:
          </p>
          <div class="itemizedlist">
            <ul type="disc">
              <li>
                <p>
                      Array
                  </p>
                <p>
                      An array of values. The value types need not be
                      consistent across the entire array. 
                  </p>
              </li>
              <li>
                <p>
                      Enum
                  </p>
                <p>
                      An enumeration, represented as an array of strings.
                  </p>
              </li>
              <li>
                <p>
                      Fixed Binary
                  </p>
                <p>
                      A simple binary type.
                  </p>
              </li>
              <li>
                <p>
                      Map
                  </p>
                <p>
                      An unordered map type where all entries are constrained
                      by a single type.
                  </p>
              </li>
            </ul>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="recordfields"></a>Record Fields</h3>
              </div>
            </div>
          </div>
          <p>
              As described in <a class="xref" href="tablesapi.html#defchildtable" title="Defining Child Tables">Defining Child Tables</a>,
              you can create child tables to hold subordinate information,
              such as addresses in a contacts database, or vendor contact
              information for an inventory system. When you do this, you
              can create an unlimited number of rows in the child table,
              and you can index the fields in the child table's rows. 
          </p>
          <p>
              The downside to using child tables is that internally they
              are stored as seperate records from the parent table. This
              means that creating/updating/deleting them represents
              multiple I/O requests, which may matter to applications that
              are performance constrained.
          </p>
          <p>
              If you have very simple requirements for subordinate data,
              and you do not want to index the fields in the subordinate
              data, you can use record fields instead of a child tables.
              Doing so means that you avoid the multiple I/O required by
              child tables. The downside is that you can not index fields
              contained in record fields.
          </p>
          <p>
              The assumption when using record fields is that you have a
              fixed known number of records that you will want to manage
              (unless you organize them as arrays). For example, for a
              contacts database, child tables allows you to have an
              unlimited number of addresses associated for each user. But
              by using records, you can associate a fixed number of
              addresses by creating a record field for each supported
              address (home and work, for example).
          </p>
          <p>
              You create a record field using <code class="literal">add-record-field</code>, 
              which puts you into a special submode within the CLI that you
              must exit or quit just as you do when creating a table:
          </p>
          <pre class="programlisting">## Enter into table creation mode
table create -name myContactsTable
## Now add the fields
add-field -type STRING -name uid
add-field -type STRING -name surname
add-field -type STRING -name familiarName
add-field -type STRING -name homePhone
add-field -type STRING -name workPhone

## Create a record field. This puts us into a new submode.
add-record-field -name homeAddress
add-field -type STRING -name street 
add-field -type STRING -name city
add-field -type STRING -name state
add-field -type INTEGER -name zip -min 00000 -max 99999
### Exit record field creation mode
exit

## Add a second record field
add-record-field -name workAddress
add-field -type STRING -name street 
add-field -type STRING -name city
add-field -type STRING -name state
add-field -type INTEGER -name zip -min 00000 -max 99999
### Exit record field creation mode
exit

## A primary key must be defined for every table
primary-key -field uid
## Exit table creation mode
exit
## Add the table to the store. Use the -wait flag to
## force the script to wait for the plan to complete
## before doing anything else.
plan add-table -name myContactsTable -wait </pre>
          <p>
                Alternatively, you can create an array of record fields.
                This allows you to create an unlimited number of address records
                per field.
            </p>
          <pre class="programlisting">## Enter into table creation mode
table create -name myContactsTable
## Now add the fields
add-field -type STRING -name uid
add-field -type STRING -name surname
add-field -type STRING -name familiarName
add-field -type STRING -name homePhone
add-field -type STRING -name workPhone

## Create an array field. This puts us into a new submode.
add-array-field -name addresses

## Create a record field for the array.
## This puts us into a new submode.
add-record-field -name address
add-field -type ENUM -name addressType -enum-values home,work,other
add-field -type STRING -name street
add-field -type STRING -name city
add-field -type STRING -name state
add-field -type INTEGER -name zip -min 00000 -max 99999
### Exit record field creation mode
exit

### Exit array field creation mode
exit

## A primary key must be defined for every table
primary-key -field uid
## Exit table creation mode
exit
## Add the table to the store. Use the -wait flag to
## force the script to wait for the plan to complete
## before doing anything else.
plan add-table -name myContactsTable -wait</pre>
          <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
            <h3 class="title">Note</h3>
            <p>
                    When you use embedded record fields, or arrays of
                    records, you cannot index fields within the records.
                    Indexing can only be performed on top-level fields. So
                    if you wanted to create an index on, say, the
                    <code class="literal">zip</code> field, you should manage this
                    information in the form of a child table.
                </p>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="tablefromavro"></a>Defining Tables using Existing Avro Schema</h3>
              </div>
            </div>
          </div>
          <p>
              If you are a user of the key/value API, then you probably
              have been using Avro schema to describe your record values.
              You can create a table based on Avro schema which currently
              exists in your store, and in so doing overlay the existing
              store records. You can then operate on that data using both
              the tables API and the key/value API so long as you do not
              evolve (change) the table definitions.  This is intended as a
              migration aid from the key/value API to the tables API.
          </p>
          <p>
              For example, suppose you have the following Avro schema
              defined in your store:
          </p>
          <pre class="programlisting">kv-&gt; show schema -name com.example.myItemRecord
{
  "type" : "record",
  "name" : "myItemRecord",
  "namespace" : "com.example",
  "fields" : [ {
    "name" : "itemType",
    "type" : "string",
    "default" : ""
  }, {
    "name" : "itemCategory",
    "type" : "string",
    "default" : ""
  }, {
    "name" : "itemClass",
    "type" : "string",
    "default" : ""
  }, {
    "name" : "itemColor",
    "type" : "string",
    "default" : ""
  }, {
    "name" : "itemSize",
    "type" : "string",
    "default" : ""
  }, {
    "name" : "price",
    "type" : "float",
    "default" : 0.0
  }, {
    "name" : "inventoryCount",
    "type" : "int",
    "default" : 0
  } ]
} </pre>
          <p>
              Then you can define a table using this schema. Note that the
              table's name does not have to be based on the schema's name:
          </p>
          <pre class="programlisting">kv-&gt; table create -name myItemTable
myItemTable-&gt; add-schema -name com.example.myItemRecord
myItemTable-&gt; show
{
  "type" : "table",
  "name" : "myItemTable",
  "id" : "myItemTable",
  "r2compat" : true,
  "description" : null,
  "shardKey" : [ ],
  "primaryKey" : [ ],
  "fields" : [ {
    "name" : "itemType",
    "type" : "STRING"
  }, {
    "name" : "itemCategory",
    "type" : "STRING"
  }, {
    "name" : "itemClass",
    "type" : "STRING"
  }, {
    "name" : "itemColor",
    "type" : "STRING"
  }, {
    "name" : "itemSize",
    "type" : "STRING"
  }, {
    "name" : "price",
    "type" : "FLOAT",
    "default" : 0.0
  }, {
    "name" : "inventoryCount",
    "type" : "INTEGER"
  } ]
}
myItemTable-&gt; </pre>
          <p>
            At this point, you need to define your primary keys and,
            optionally, your shard keys in the same way you would any
            table. You also need to add the table to the store in the same
            way as always.
        </p>
          <pre class="programlisting">myItemTable-&gt;primary-key -field itemType -field itemCategory
myItemTable-&gt;exit
kv-&gt;plan add-table -name myItemTable -wait </pre>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="keyonlydata"></a>Tables Compatible with Key-Only Entries (-r2-compat)</h4>
                </div>
              </div>
            </div>
            <p>
                    If you are a user of the key/value API, you might have
                    created store entries that have only keys. These
                    entries have no schema. In fact, they have no data of
                    any kind. In this case, you can create tables that are
                    compatible with these legacy entries using the
                    <code class="literal">table create</code> command's
                    <code class="literal">-r2-compat</code> flag.
                </p>
            <p>
                    For example, suppose you have key-only entries of the
                    format:
                </p>
            <pre class="programlisting">/User/&lt;id&gt;</pre>
            <p>
                    where <code class="literal">&lt;id&gt;</code> is a unique string
                    ID. You can create a table to overlay this key space by
                    doing this:
                </p>
            <pre class="programlisting">kv-&gt; table create -name User -r2-compat
User-&gt; add-field -name id -type String
User-&gt; primary-key -field id
User-&gt; exit
Table User built.
kv-&gt; plan add-table -name User -wait </pre>
            <p>
                    If you did not use the <code class="literal">-r2-compat</code>
                    flag, the underlying keys generated for the table's
                    entries would start with something other than
                    <code class="literal">User</code>.
                </p>
            <p>
                    Note that when you create tables using existing Avro
                    schema, the <code class="literal">-r2-compat</code> flag is
                    automatically used.
                </p>
            <p>
                    Also note that as is the case when generating tables
                    using Avro schema, the overlay only works so long as
                    you do not evolve the tables.
                </p>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="tableevolve"></a>Table Evolution</h3>
              </div>
            </div>
          </div>
          <p>
              In the event that you must update your application at some
              point after it goes into production, there is a good chance
              that your tables will also have to be updated to either use
              new fields or remove existing fields that are no longer in
              use. You do this through the use of the <code class="literal">table evolve</code>
              and <code class="literal">plan evolve-table</code> commands.
          </p>
          <p>
              Note that you cannot remove a field if it is a primary key
              field.
          </p>
          <p>
              Tables can only be evolved if they have already been added to
              the store using either the <code class="literal">plan add-table</code>
              or <code class="literal">plan evolve-table</code> commands.
          </p>
          <p>
              For example, the following script evolves the table that was
              created in the previous section. It adds a field and deletes
              another one. Again, we use a script to evolve our table so as
              to ensure consistency across engineering, test and
              production.
          </p>
          <pre class="programlisting">## Enter into table evolution mode
table evolve -name myTable
## Add a field
add-field -type STRING -name itemCategory
## Remove a field.
remove-field -name percentage
## Exit table creation mode
exit
plan evolve-table -name myTable -wait </pre>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="tablecommands"></a>Table Manipulation Commands</h3>
              </div>
            </div>
          </div>
          <p>
              This section briefly describes the CLI commands that you use
              to manipulate tables. This section is for advertisement
              purposes only.
          </p>
          <p>
              An exhaustive list of all CLI commands, and their syntax, can
              be found in the 
              <a href="../AdminGuide/cli_command_reference.html" class="olink">
                  KVStore Command Reference.  
              </a>
              You can also see the command
              syntax for all CLI commands using the CLI
              <code class="literal">help</code> command. 
          </p>
          <div class="itemizedlist">
            <ul type="disc">
              <li>
                <p>
                      <code class="literal">plan add-table</code>
                  </p>
                <p>
                      Adds a table to the store that has been created but
                      not yet added. Use the <code class="literal">table create</code>
                      command to create the table. 
                  </p>
              </li>
              <li>
                <p>
                      <code class="literal">plan evolve-table</code>
                  </p>
                <p>
                      Adds a table to the store that has been evolved using
                      the <code class="literal">table evolve</code> command.
                  </p>
              </li>
              <li>
                <p>
                      plan remove-table
                  </p>
                <p>
                      Removes an existing table from the store.
                  </p>
              </li>
              <li>
                <p>
                      show tables
                  </p>
                <p>
                      Shows all tables and child tables that have been
                      added to the store.
                  </p>
              </li>
              <li>
                <p>
                      table clear
                  </p>
                <p>
                      Clears a table of all schema. This command works only
                      on tables that have been created using the 
                      <code class="literal">table create</code> command, but not yet
                      added to the store using the <code class="literal">plan add-table</code>
                      command.
                  </p>
              </li>
              <li>
                <p>
                      table create
                  </p>
                <p>
                      Enters into table creation mode in which you can
                      design the schema for the table. This mode offers a
                      series of sub-commands:
                  </p>
                <div class="itemizedlist">
                  <ul type="circle">
                    <li>
                      <p>
                              add-array-field
                          </p>
                      <p>
                              Adds a field to the table that accepts an
                              array.
                          </p>
                    </li>
                    <li>
                      <p>
                              add-field
                          </p>
                      <p>
                              Adds a field that accepts data of a simple
                              type. You must identify the data's type. For
                              example, INTEGER, LONG, DOUBLE, etc.
                          </p>
                    </li>
                    <li>
                      <p>
                              add-map-field
                          </p>
                      <p>
                              Adds a field that accepts a map.
                          </p>
                    </li>
                    <li>
                      <p>
                              add-schema
                          </p>
                      <p>
                              Build the table using specified Avro schema.
                          </p>
                    </li>
                    <li>
                      <p>
                              cancel
                          </p>
                      <p>
                              Cancels the table creation. This returns you
                              to the main admin prompt, abandoning any work
                              that you might have performed when creating
                              the table.
                          </p>
                    </li>
                    <li>
                      <p>
                              exit
                          </p>
                      <p>
                              Saves the work you performed when creating
                              the table, and returns you to the main admin
                              prompt. After exiting table creation mode,
                              you must issue the <code class="literal">plan add-table</code>
                              command to add the table to your store.
                          </p>
                    </li>
                    <li>
                      <p>
                              primary-key
                          </p>
                      <p>
                              The identified field is the table's primary
                              key. Every table must have at least one field
                              identified as its primary key. See
                              <a class="xref" href="primaryshardkeys.html" title="Chapter 5. Primary and Shard Key Design">Primary and Shard Key Design</a>
                              for more information.
                          </p>
                    </li>
                    <li>
                      <p>
                              remove-field
                          </p>
                      <p>
                              Removes the identified field from the table.
                          </p>
                    </li>
                    <li>
                      <p>
                              set-description
                          </p>
                      <p>
                              Sets a plain-text description of the table.
                              Use this to document what the table is used
                              for.
                          </p>
                    </li>
                    <li>
                      <p>
                              shard-key
                          </p>
                      <p>
                              Sets a shard key for the table. See
                              <a class="xref" href="primaryshardkeys.html" title="Chapter 5. Primary and Shard Key Design">Primary and Shard Key Design</a>
                              for more information.
                          </p>
                    </li>
                    <li>
                      <p>
                              show
                          </p>
                      <p>
                              Shows the current fields defined for the
                              table.
                          </p>
                    </li>
                  </ul>
                </div>
              </li>
              <li>
                <p>
                      table evolve
                  </p>
                <p>
                      Allows you to evolve (modify) a table that has been
                      added to the store. This command puts you into a
                      special mode that allows you to add and remove fields
                      in much the same way as you can when using
                      <code class="literal">table create</code>. Upon completing this
                      command, you must add your evolved table to the
                      store using the <code class="literal">plan evolve-table</code>
                      command.
                  </p>
              </li>
              <li>
                <p>
                      table list
                  </p>
                <p>
                      Lists all the table that have been built but not yet
                      created or evolved using <code class="literal">plan add-table</code>
                      or <code class="literal">plan evolve-table.</code>.
                  </p>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="authentication.html">Prev</a> </td>
          <td width="20%" align="center"> </td>
          <td width="40%" align="right"> <a accesskey="n" href="createindex.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Using the Authentication APIs </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Home</a>
          </td>
          <td width="40%" align="right" valign="top"> Creating Indexes</td>
        </tr>
      </table>
    </div>
  </body>
</html>
