<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Parallel Scans</title>
    <link rel="stylesheet" href="gettingStarted.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="start" href="index.html" title="Getting Started with Oracle NoSQL Database Tables" />
    <link rel="up" href="tableget.html" title="Chapter 7. Reading Table Rows" />
    <link rel="prev" href="indexread.html" title="Reading Indexes" />
    <link rel="next" href="versions.html" title="Chapter 8. Using Versions" />
  </head>
  <body>
    <div xmlns="" class="navheader">
      <div class="libver">
        <p>Library Version DRAFT</p>
      </div>
      <table width="100%" summary="Navigation header">
        <tr>
          <th colspan="3" align="center">Parallel Scans</th>
        </tr>
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="indexread.html">Prev</a> </td>
          <th width="60%" align="center">Chapter 7. Reading Table Rows</th>
          <td width="20%" align="right"> <a accesskey="n" href="versions.html">Next</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="sect1" lang="en" xml:lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="parallelscan"></a>Parallel Scans</h2>
          </div>
        </div>
      </div>
      <p>
            Until now the reads that we have discussed in this chapter are
            single-threaded. Reads are performed one partition at a time,
            in sequence, until all the desired rows are retrieved. This has
            obvious performance implications if you are retrieving a large
            number of rows that span multiple shards (such as might occur
            if you are iterating over an index, or even over a partial
            primary key). However, you can speed up the read performance by
            using parallel scans.
        </p>
      <p>
            Parallel scan retrieves the records from each shard in parallel
            and allows the client to receive and process them in parallel.
            You can specify how many threads to use to perform the
            retrieval.  If more threads are specified on the client side,
            then the user can expect better retrieval performance —
            until processor or network resources are saturated.
        </p>
      <p>
            To specify that a parallel scan is to be performed, you use
            <code class="classname">TableIteratorOptions</code> to identify the
            maximum number of client-side threads to be used for the scan,
            as well as the number of results per request and the maximum
            number of result batches that the Oracle NoSQL Database client can hold before
            the scan pauses. You pass this to
            <code class="methodname">TableAPI.tableIterator()</code>. This creates
            a <code class="classname">TableIterator</code> that uses the specified
            parallel scan configuration.
        </p>
      <p>
            For example, to retrieve all of the records in the store using
            5 threads in parallel, you would do this:
        </p>
      <a id="parallelscan-2"></a>
      <pre class="programlisting">package kvstore.basicExample;

...

import oracle.kv.Consistency;
import oracle.kv.Direction;
import oracle.kv.KVStore;
import oracle.kv.table.FieldRange;
import oracle.kv.table.Index;
import oracle.kv.table.IndexKey;
import oracle.kv.table.MultiRowOption;
import oracle.kv.table.Row;
import oracle.kv.table.Table;
import oracle.kv.table.TableAPI;
import oracle.kv.table.TableIterator;
import oracle.kv.table.TableIteratorOptions;

...

// KVStore handle creation is omitted for brevity

...

TableAPI tableH = kvstore.getTableAPI();

Table myTable = tableH.getTable("myTable");

// Construct the IndexKey. The name we gave our index when 
// we created it was 'DoB'.
Index dobIdx = myTable.getIndex("DoB");
IndexKey dobIdxKey = dobIdx.createIndexKey();

<strong class="userinput"><code>TableIteratorOptions tio =
    new TableIteratorOptions(Direction.UNORDERED,
                             Consistency.NONE_REQUIRED,
                             0,     // timeout
                             null,  // timeout units
                             5,     // number of concurrent
                                    // threads
                             0,     // results per request
                             0);    // max result sets</code></strong>
// Exception handling is omitted, but in production code
// ConsistencyException, RequestTimeException, and FaultException
// would have to be handled.
TableIterator&lt;Row&gt; iter = 
    tableH.tableIterator(dobIdxKey, null, <strong class="userinput"><code>tio</code></strong>);
while (iter.hasNext()) {
    Row row = iter.next();
    // Examine your row's fields here
} </pre>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="indexread.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="tableget.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="versions.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Reading Indexes </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Home</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 8. Using Versions</td>
        </tr>
      </table>
    </div>
  </body>
</html>
