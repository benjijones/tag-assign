<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 5. Primary and Shard Key Design</title>
    <link rel="stylesheet" href="gettingStarted.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="start" href="index.html" title="Getting Started with Oracle NoSQL Database Tables" />
    <link rel="up" href="index.html" title="Getting Started with Oracle NoSQL Database Tables" />
    <link rel="prev" href="createindex.html" title="Creating Indexes" />
    <link rel="next" href="rowdata.html" title="Row Data" />
  </head>
  <body>
    <div xmlns="" class="navheader">
      <div class="libver">
        <p>Library Version DRAFT</p>
      </div>
      <table width="100%" summary="Navigation header">
        <tr>
          <th colspan="3" align="center">Chapter 5. Primary and Shard Key Design</th>
        </tr>
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="createindex.html">Prev</a> </td>
          <th width="60%" align="center"> </th>
          <td width="20%" align="right"> <a accesskey="n" href="rowdata.html">Next</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="chapter" lang="en" xml:lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="primaryshardkeys"></a>Chapter 5. Primary and Shard Key Design</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <p>
          <b>Table of Contents</b>
        </p>
        <dl>
          <dt>
            <span class="sect1">
              <a href="primaryshardkeys.html#primarykeys">Primary Keys</a>
            </span>
          </dt>
          <dd>
            <dl>
              <dt>
                <span class="sect2">
                  <a href="primaryshardkeys.html#partialprimarykeys">Partial Primary Keys</a>
                </span>
              </dt>
              <dt>
                <span class="sect2">
                  <a href="primaryshardkeys.html#shardkeys">Shard Keys</a>
                </span>
              </dt>
            </dl>
          </dd>
          <dt>
            <span class="sect1">
              <a href="rowdata.html">Row Data</a>
            </span>
          </dt>
        </dl>
      </div>
      <p>
      <span class="emphasis"><em>Primary keys</em></span> and <span class="emphasis"><em>shard keys</em></span>
      are important concepts for your table design. What you use for
      primary and shard keys has implications in terms of your ability to
      read multiple rows at a time. But beyond that, your key design has
      important performance implications.
  </p>
      <div class="sect1" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="primarykeys"></a>Primary Keys</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <dl>
            <dt>
              <span class="sect2">
                <a href="primaryshardkeys.html#partialprimarykeys">Partial Primary Keys</a>
              </span>
            </dt>
            <dt>
              <span class="sect2">
                <a href="primaryshardkeys.html#shardkeys">Shard Keys</a>
              </span>
            </dt>
          </dl>
        </div>
        <p>
          Every table must have one or more fields designated as the primary
          key. This designation occurs at the time that the table is created,
          and cannot be changed after the fact. A table's primary key uniquely 
          identifies every row in the table. In the simplest case, it is used
          to retrieve a specific row so that it can be examined and/or
          modified.
      </p>
        <p>
          For example, a table might have five fields:
          <code class="literal">productName</code>, <code class="literal">productType</code>,
          <code class="literal">color</code>, <code class="literal">size</code>, and
          <code class="literal">inventoryCount</code>. To retrieve individual rows
          from the table, it might be enough to just know the product's
          name. In this case, you would set the primary key field as
          <code class="literal">productName</code> and then retrieve rows based on
          the product name that you want to examine/manipulate.
      </p>
        <p>
          In this case, the CLI script that you would use to create this table
          might be:
      </p>
        <pre class="programlisting">## Enter into table creation mode
table create -name myProducts
## Now add the fields
add-field -type STRING -name productName
add-field -type STRING -name productType
add-field -type ENUM -name color -enum-values blue,green,red
add-field -type ENUM -name size -enum-values small,medium,blue
add-field -type INTEGER -name inventoryCount
## A primary key must be defined for every table
## Here, we will define field 'productName' as the primary key.
primary-key -field productName
## Exit table creation mode
exit
## Add the table to the store. Use the -wait flag to
## force the script to wait for the plan to complete
## before doing anything else.
plan add-table -name myProducts -wait </pre>
        <p>
          However, you can use multiple fields for your primary keys. 
          On a functional level, doing this allows you to delete multiple rows
          in your table in a single atomic operation. In addition, multiple
          primary keys allows you to retrieve a subset of the rows in your
          table in a single atomic operation.
      </p>
        <p>
          We describe how to retrieve multiple rows from your table in
          <a class="xref" href="tableget.html" title="Chapter 7. Reading Table Rows">Reading Table Rows</a>. We show how to delete
          multiple rows at a time in 
          <a class="xref" href="recorddelete.html#multidelete" title="Using multiDelete()">Using multiDelete()</a>.
      </p>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="partialprimarykeys"></a>Partial Primary Keys</h3>
              </div>
            </div>
          </div>
          <p>
              Some of the methods you use to perform multi-row operations
              allow, or even require, a partial primary key. A partial
              primary key is, simply, a key where only some of the
              fields comprising the row's primary key are specified.
          </p>
          <p>
              For example, the following example specifies three fields for
              the table's primary key:
          </p>
          <pre class="programlisting">## Enter into table creation mode
table create -name myProducts
## Now add the fields
add-field -type STRING -name productName
add-field -type STRING -name productType
add-field -type STRING -name productClass
add-field -type ENUM -name color -enum-values blue,green,red
add-field -type ENUM -name size -enum-values small,medium,large
add-field -type INTEGER -name inventoryCount
## A primary key must be defined for every table
primary-key -field productName -field productType -field productClass
## Exit table creation mode
exit
## Add the table to the store. Use the -wait flag to
## force the script to wait for the plan to complete
## before doing anything else.
plan add-table -name myProducts -wait </pre>
          <p>
                In this case, a full primary key would be one where you
                provide value for all three primary key fields: 
                <code class="literal">productName</code>, <code class="literal">productType</code>,
                and <code class="literal">productClass</code>. A partial primary key
                would be one where you provide values for only one or two
                of those fields.
            </p>
          <p>
                Note that order matters when specifying a partial key. The
                partial key must be a subset of the full key, starting with
                the first field specified and then adding fields in order.
                So the following partial keys are valid:
            </p>
          <table class="simplelist" border="0" summary="Simple list">
            <tr>
              <td>
                <code class="literal">productName</code>
              </td>
            </tr>
            <tr>
              <td><code class="literal">productName</code>, <code class="literal">productType</code></td>
            </tr>
          </table>
          <p>
                But a partial key comprised of <code class="literal">productType</code>
                and <code class="literal">productClass</code> is not.
            </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="shardkeys"></a>Shard Keys</h3>
              </div>
            </div>
          </div>
          <p>
              Shard keys identify which primary key fields are meaningful
              in terms of shard storage. That is, rows which contain the
              same values for all the shard key fields are guaranteed to be
              stored on the same shard. This matters for some operations
              that promise atomicity of the results. (See 
              <a class="xref" href="multiop.html" title="Chapter 11. Executing a Sequence of Operations">Executing a Sequence of Operations</a>
              for more information.)
          </p>
          <p>
              For example, suppose you set the following primary keys:
          </p>
          <pre class="programlisting">primary-key -field productType -field productName -field productClass</pre>
          <p>
              You can guarantee that rows are placed on the same shard
              using the values set for the <code class="literal">productType</code>
              and <code class="literal">productName</code> fields like this:
          </p>
          <pre class="programlisting">shard-key -field productType -field productName</pre>
          <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
            <h3 class="title">Note</h3>
            <p>
                  Shard key fields  must be a first-to-last subset of the
                  primary key fields, and they must be specified
                  in the same order as were the primary key fields.
                  In the previous example, the following would
                  result in an error:
              </p>
            <pre class="programlisting">shard-key -field productClass</pre>
          </div>
          <p>
              Minor keys offer performance improvements if used correctly,
              but in order to understand how you need to understand
              performance issues surrounding the data you place in your
              tables. We discuss these issues next.
          </p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="createindex.html">Prev</a> </td>
          <td width="20%" align="center"> </td>
          <td width="40%" align="right"> <a accesskey="n" href="rowdata.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Creating Indexes </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Home</a>
          </td>
          <td width="40%" align="right" valign="top"> Row Data</td>
        </tr>
      </table>
    </div>
  </body>
</html>
